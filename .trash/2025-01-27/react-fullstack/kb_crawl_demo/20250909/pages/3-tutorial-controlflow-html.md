---
source_url: https://docs.python.org/3/tutorial/controlflow.html
crawled_at: 2025-09-09T06:03:54.437102
page_title: 4. More Control Flow Tools — Python 3.13.7 documentation
---

# 4. More Control Flow Tools — Python 3.13.7 documentation

## Summary
4. More Control Flow Tools Â¶ As well as the while statement just introduced, Python uses a few more that we will encounter in this chapter.

## Key Points
- Section: 4. More Control Flow ToolsÂ¶
- Key topic: print
- Key topic: case
- Additional information available
- Additional information available

## Content
4. More Control Flow Tools Â¶ As well as the while statement just introduced, Python uses a few more that we will encounter in this chapter. 4.1. if Statements Â¶ Perhaps the most well-known statement type is the if statement. For example: >>> x = int ( input ( "Please enter an integer: " )) Please enter an integer: 42 >>> if x < 0 : ... x = 0 ... print ( 'Negative changed to zero' ) ... elif x == 0 : ... print ( 'Zero' ) ... elif x == 1 : ... print ( 'Single' ) ... else : ... print ( 'More' ) ... More There can be zero or more elif parts, and the else part is optional. The keyword â elif â is short for âelse ifâ, and is useful to avoid excessive indentation. An if â¦ elif â¦ elif â¦ sequence is a substitute for the switch or case statements found in other languages. If youâre comparing the same value to several constants, or checking for specific types or attributes, you may also find the match statement useful. For more details see match Statements . 4.2. for Statements Â¶ The for statement in Python differs a bit from what you may be used to in C or Pascal. Rather than always iterating over an arithmetic progression of numbers (like in Pascal), or giving the user the ability to define both the iteration step and halting condition (as C), Pythonâs for statement iterates over the items of any sequence (a list or a string), in the order that they appear in the sequence. For example (no pun intended): >>> # Measure some strings: >>> words = [ 'cat' , 'window' , 'defenestrate' ] >>> for w in words : ... print ( w , len ( w )) ... cat 3 window 6 defenestrate 12 Code that modifies a collection while iterating over that same collection can be tricky to get right. Instead, it is usually more straight-forward to loop over a copy of the collection or to create a new collection: # Create a sample collection users = { 'Hans' : 'active' , 'ÃlÃ©onore' : 'inactive' , 'æ¯å¤ªé' : 'active' } # Strategy: Iterate over a copy for user , status in users . copy () . items (): if status == 'inactive' : del users [ user ] # Strategy: Create a new collection active_users = {} for user , status in users . items (): if status == 'active' : active_users [ user ] = status 4.3. The range() Function Â¶ If you do need to iterate over a sequence of numbers, the built-in function range() comes in handy. It generates arithmetic progressions: >>> for i in range ( 5 ): ... print ( i ) ... 0 1 2 3 4 The given end point is never part of the generated sequence; range(10) generates 10 values, the legal indices for items of a sequence of length 10. It is possible to let the range start at another number, or to specify a different increment (even negative; sometimes this is called the âstepâ): >>> list ( range ( 5 , 10 )) [5, 6, 7, 8, 9] >>> list ( range ( 0 , 10 , 3 )) [0, 3, 6, 9] >>> list ( range ( - 10 , - 100 , - 30 )) [-10, -40, -70] To iterate over the indices of a sequence, you can combine range() and len() as follows: >>> a = [ 'Mary' , 'had' , 'a' , 'little' , 'lamb' ] >>> for i in range ( len ( a )): ... print ( i , a [ i ]) ... 0 Mary 1 had 2 a 3 little 4 lamb In most such cases, however, it is convenient to use the enumerate() function, see Looping Techniques . A strange thing happens if you just print a range: >>> range ( 10 ) range(0, 10) In many ways the object returned by range() behaves as if it is a list, but in fact it isnât. It is an object which returns the successive items of the desired sequence when you iterate over it, but it doesnât really make the list, thus saving space. We say such an object is iterable , that is, suitable as a target for functions and constructs that expect something from which they can obtain successive items until the supply is exhausted. We have seen that the for statement is such a construct, while an example of a function that takes an iterable is sum() : >>> sum ( range ( 4 )) # 0 + 1 + 2 + 3 6 Later we will see more functions that return iterables and take iterables as arguments. In chapter Data Structures , we will discuss in more detail about list() . 4.4. break and continue Statements Â¶ The break statement breaks out of the innermost enclosing for or while loop: >>> for n in range ( 2 , 10 ): ... for x in range ( 2 , n ): ... if n % x == 0 : ... print ( f " { n } equals { x } * { n // x } " ) ... break ... 4 equals 2 * 2 6 equals 2 * 3 8 equals 2 * 4 9 equals 3 * 3 The continue statement continues with the next iteration of the loop: >>> for num in range ( 2 , 10 ): ... if num % 2 == 0 : ... print ( f "Found an even number { num } " ) ... continue ... print ( f "Found an odd number { num } " ) ... Found an even number 2 Found an odd number 3 Found an even number 4 Found an odd number 5 Found an even number 6 Found an odd number 7 Found an even number 8 Found an odd number 9 4.5. else Clauses on Loops Â¶ In a for or while loop the break statement may be paired with an else clause. If the loop finishes without executing the break , the else clause executes. In a for loop, the else clause is executed after the loop finishes its final iteration, that is, if no break occurred. In a while loop, itâs executed after the loopâs condition becomes false. In either kind of loop, the else clause is not executed if the loop was terminated by a break . Of course, other ways of ending the loop early, such as a return or a raised exception, will also skip execution of the else clause. This is exemplified in the following for loop, which searches for prime numbers: >>> for n in range ( 2 , 10 ): ... for x in range ( 2 , n ): ... if n % x == 0 : ... print ( n , 'equals' , x , '*' , n // x ) ... break ... else : ... # loop fell through without finding a factor ... print ( n , 'is a prime number' ) ... 2 is a prime number 3 is a prime number 4 equals 2 * 2 5 is a prime number 6 equals 2 * 3 7 is a prime number 8 equals 2 * 4 9 equals 3 * 3 (Yes, this is the correct code. Look closely: the else clause belongs to the for loop, not the if statement.) One way to think of the else clause is to imagine it paired with the if inside the loop. As the loop executes, it will run a sequence like if/if/if/else. The if is inside the loop, encountered a number of times. If the condition is ever true, a break will happen. If the condition is never true, the else clause outside the loop will execute. When used with a loop, the else clause has more in common with the else clause of a try statement than it does with that of if statements: a try statementâs else clause runs when no exception occurs, and a loopâs else clause runs when no break occurs. For more on the try statement and exceptions, see Handling Exceptions . 4.6. pass Statements Â¶ The pass statement does nothing. It can be used when a statement is required syntactically but the program requires no action. For example: >>> while True : ... pass # Busy-wait for keyboard interrupt (Ctrl+C) ... This is commonly used for creating minimal classes: >>> class MyEmptyClass : ... pass ... Another place pass can be used is as a place-holder for a function or conditional body when you are working on new code, allowing you to keep thinking at a more abstract level. The pass is silently ignored: >>> def initlog ( * args ): ... pass # Remember to implement this! ... For this last case, many people use the ellipsis literal ... instead of pass . This use has no special meaning to Python, and is not part of the language definition (you could use any constant expression here), but ... is used conventionally as a placeholder body as well. See The Ellipsis Object . 4.7. match Statements Â¶ A match statement takes an expression and compares its value to successive patterns given as one or more case blocks. This is superficially similar to a switch statement in C, Java or JavaScript (and many other languages), but itâs more similar to pattern matching in languages like Rust or Haskell. Only the first pattern that matches gets executed and it can also extract components (sequence elements or object attributes) from the value into variables. The simplest form compares a subject value against one or more literals: def http_error ( status ): match status : case 400 : return "Bad request" case 404 : return "Not found" case 418 : return "I'm a teapot" case _ : return "Something's wrong with the internet" Note the last block: the âvariable nameâ _ acts as a wildcard and never fails to match. If no case matches, none of the branches is executed. You can combine several literals in a single pattern using | (âorâ): case 401 | 403 | 404 : return "Not allowed" Patterns can look like unpacking assignments, and can be used to bind variables: # point is an (x, y) tuple match point : case ( 0 , 0 ): print ( "Origin" ) case ( 0 , y ): print ( f "Y= { y } " ) case ( x , 0 ): print ( f "X= { x } " ) case ( x , y ): print ( f "X= { x } , Y= { y } " ) case _ : raise ValueError ( "Not a point" ) Study that one carefully! The first pattern has two literals, and can be thought of as an extension of the literal pattern shown above. But the next two patterns combine a literal and a variable, and the variable binds a value from the subject ( point ). The fourth pattern captures two values, which makes it conceptually similar to the unpacking assignment (x, y) = point . If you are using classes to structure your data you can use the class name followed by an argument list resembling a constructor, but with the ability to capture attributes into variables: class Point : def __init__ ( self , x , y ): self . x = x self . y = y def where_is ( point ): match point : case Point ( x = 0 , y = 0 ): print ( "Origin" ) case Point ( x = 0 , y = y ): print ( f "Y= { y } " ) case Point ( x = x , y = 0 ): print ( f "X= { x } " ) case Point (): print ( "Somewhere else" ) case _ : print ( "Not a point" ) You can use positional parameters with some builtin classes that provide an ordering for their attributes (e.g. dataclasses). You can also define a specific position for attributes in patterns by setting the __match_args__ special attribute in your classes. If itâs set to (âxâ, âyâ), the following patterns are all equivalent (and all bind the y attribute to the var variable): Point ( 1 , var ) Point ( 1 , y = var ) Point ( x = 1 , y = var ) Point ( y = var , x = 1 ) A recommended way to read patterns is to look at them as an extended form of what you would put on the left of an assignment, to understand which variables would be set to what. Only the standalone names (like var above) are assigned to by a match statement. Dotted names (like foo.bar ), attribute names (the x= and y= above) or class names (recognized by the â(â¦)â next to them like Point above) are never assigned to. Patterns can be arbitrarily nested. For example, if we have a short list of Points, with __match_args__ added, we could match it like this: class Point : __match_args__ = ( 'x' , 'y' ) def __init__ ( self , x , y ): self . x = x self . y = y match points : case []: print ( "No points" ) case [ Point ( 0 , 0 )]: print ( "The origin" ) case [ Point ( x , y )]: print ( f "Single point { x } , { y } " ) case [ Point ( 0 , y1 ), Point ( 0 , y2 )]: print ( f "Two on the Y axis at { y1 } , { y2 } " ) case _ : print ( "Something else" ) We can add an if clause to a pattern, known as a âguardâ. If the guard is false, match goes on to try the next case block. Note that value capture happens before the guard is evaluated: match point : case Point ( x , y ) if x == y : print ( f "Y=X at { x } " ) case Point ( x , y ): print ( f "Not on the diagonal" ) Several other key features of this statement: Like unpacking assignments, tuple and list patterns have exactly the same meaning and actually match arbitrary sequences. An important exception is that they donât match iterators or strings. Sequence patterns support extended unpacking: [x, y, *rest] and (x, y, *rest) work similar to unpacking assignments. The name after * may also be _ , so (x, y, *_) matches a sequence of at least two items without binding the remaining items. Mapping patterns: {"bandwidth": b, "latency": l} captures the "bandwidth" and "latency" values from a dictionary. Unlike sequence patterns, extra keys are ignored. An unpacking like **rest is also supported. (But **_ would be redundant, so it is not allowed.) Subpatterns may be captured using the as keyword: case ( Point ( x1 , y1 ), Point ( x2 , y2 ) as p2 ): ... will capture the second element of the input as p2 (as long as the input is a sequence of two points) Most literals are compared by equality, however the singletons True , False and None are compared by identity. Patterns may use named constants. These must be dotted names to prevent them from being interpreted as capture variable: from enum import Enum class Color ( Enum ): RED = 'red' GREEN = 'green' BLUE = 'blue' color = Color ( input ( "Enter your choice of 'red', 'blue' or 'green': " )) match color : case Color . RED : print ( "I see red!" ) case Color . GREEN : print ( "Grass is green" ) case Color . BLUE : print ( "I'm feeling the blues :(" ) For a more detailed explanation and additional examples, you can look into PEP 636 which is written in a tutorial format. 4.8. Defining Functions Â¶ We can create a function that writes the Fibonacci series to an arbitrary boundary: >>> def fib ( n ): # write Fibonacci series less than n ... """Print a Fibonacci series less than n.""" ... a , b = 0 , 1 ... while a < n : ... print ( a , end = ' ' ) ... a , b = b , a + b ... print () ... >>> # Now call the function we just defined: >>> fib ( 2000 ) 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 The keyword def introduces a function definition . It must be followed by the function name and the parenthesized list of formal parameters. The statements that form the body of the function start at the next line, and must be indented. The first statement of the function body can optionally be a string literal; this string literal is the functionâs documentation string, or docstring . (More about docstrings can be found in the section Documentation Strings .) There are tools which use docstrings to automatically produce online or printed documentation, or to let the user interactively browse through code; itâs good practice to include docstrings in code that you write, so make a habit of it. The execution of a function introduces a new symbol table used for the local variables of the function. More precisely, all variable assignments in a function store the value in the local symbol table; whereas variable references first look in the local symbol table, then in the local symbol tables of enclosing functions, then in the global symbol table, and finally in the table of built-in names. Thus, global variables and variables of enclosing functions cannot be directly assigned a value within a function (unless, for global variables, named in a global statement, or, for variables of enclosing functions, named in a nonlocal statement), althou

## RAG Chunk
```
Title: 4. More Control Flow Tools — Python 3.13.7 documentation

Sections: 4. More Control Flow ToolsÂ¶

4. More Control Flow Tools Â¶ As well as the while statement just introduced, Python uses a few more that we will encounter in this chapter. 4.1. if Statements Â¶ Perhaps the most well-known statement type is the if statement. For example: >>> x = int ( input ( "Please enter an integer: " )) Please enter an integer: 42 >>> if x < 0 : ... x = 0 ... print ( 'Negative changed to zero' ) ... elif x == 0 : ... print ( 'Zero' ) ... elif x == 1 : ... print ( 'Single' ) ... else : ... print ( 'More' ) ... More There can be zero or more elif parts, and the else part is optional. The keyword â elif â is short for âelse ifâ, and is useful to avoid excessive indentation. An if â¦ elif â¦ elif â¦ sequence is a substitute for the switch or case statements found in other languages. If youâre comparing the same value to several constants, or checking for specific types or attributes, you may also find the match statement useful. For more details see match Statements . 4.2. for Statements Â¶ The for statement in Python differs a bit from what you may be used to in C or Pascal. Rather than always iterating over an arithmetic progression of numbers (like in Pascal), or giving the user the ability to define both the iteration step and halting condition (as C), Pythonâs for statement iterates over the items of any sequence (a list or a string), in the order that they appear in t
```
